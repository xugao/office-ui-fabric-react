import { IStyle } from '@fluentui/merge-styles';
import { Theme } from '@fluentui/theme';
import { useTheme } from './useTheme';
import { useWindow } from '@fluentui/react-window-provider';
import { useStyleRenderer } from './styleRenderers/useStyleRenderer';
import { StyleRenderer, StyleRendererOptions } from './styleRenderers/types';
import { warn } from '@fluentui/utilities';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const graphGet = (graphNode: Map<any, any>, path: any[]): any | undefined => {
  for (const key of path) {
    graphNode = graphNode.get(key);

    if (!graphNode) {
      return;
    }
  }

  return graphNode;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const graphSet = (graphNode: Map<any, any>, path: any[], value: any) => {
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];

    let current = graphNode.get(key);

    if (!current) {
      current = new Map();

      graphNode.set(key, current);
    }

    graphNode = current;
  }

  graphNode.set(path[path.length - 1], value);
};

/** Options that can be provided to the hook generated by `makeStyles`. */
export type UseStylesOptions = {
  theme?: Theme;
  renderer?: StyleRenderer;
};

export type KeyframesSet = { [key: string]: IStyle };
/**
 * Registers a css object, optionally as a function of the theme.
 *
 * @param styleOrFunction - Either a css javascript object, or a function which takes in `ITheme`
 * and returns a css javascript object.
 */
export function makeAnimations<TStyleSet extends { [key: string]: IStyle }>(
  styleOrFunction: [KeyframesSet, TStyleSet] | ((theme: Theme) => [KeyframesSet, TStyleSet]),
): (options?: UseStylesOptions) => { [key in keyof TStyleSet]: string } {
  // Create graph of inputs to map to output.
  const graph = new Map();

  return (options: UseStylesOptions = {}) => {
    let { theme, renderer } = options;
    const win = useWindow();
    const contextualTheme = useTheme();
    const contextualRenderer = useStyleRenderer();

    theme = theme || contextualTheme || {};
    renderer = (renderer || contextualRenderer) as StyleRenderer;

    const id = renderer.getId();
    const isStyleFunction = typeof styleOrFunction === 'function';
    const path = isStyleFunction ? [id, win, theme] : [id, win];
    let value = graphGet(graph, path);

    if (!value) {
      const userStyles: [KeyframesSet, TStyleSet] = isStyleFunction
        ? (styleOrFunction as (theme: Theme) => [KeyframesSet, TStyleSet])(theme!)
        : (styleOrFunction as [KeyframesSet, TStyleSet]);
      const [keyframes, styles] = [...userStyles];
      const rendererOptions = { targetWindow: win, rtl: !!theme!.rtl };

      const registeredKeyframes = renderKeyframes(renderer, rendererOptions, keyframes);
      Object.keys(styles).forEach((styleKey: string) => {
        replaceReferencedKeyframe(styles[styleKey], registeredKeyframes);
      });

      value = renderer.renderStyles(styles, rendererOptions);

      graphSet(graph, path, value);
    }

    return value;
  };
}

const refRegExp = /\$([\w-]+)/g;

function renderKeyframes(
  renderer: StyleRenderer,
  rendererOptions: StyleRendererOptions,
  keyframesSet: KeyframesSet,
): { [key: string]: string } {
  const keyframes: { [key: string]: string } = {};
  for (const key in keyframesSet) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    keyframes[key] = renderer.renderKeyframes(keyframesSet[key] as any, rendererOptions);
  }

  return keyframes;
}

const replaceReferencedKeyframe = (style: IStyle, keyframes: { [key: string]: string }) => {
  if (Array.isArray(style)) {
    style.forEach((s: Omit<IStyle, 'IStyleBaseArray'>) => replaceReferencedKeyframeImpl(s, keyframes));
  } else {
    replaceReferencedKeyframeImpl(style as Omit<IStyle, 'IStyleBaseArray'>, keyframes);
  }
};

const replaceReferencedKeyframeImpl = (
  style: Omit<IStyle, 'IStyleBaseArray'>,
  keyframes: { [key: string]: string },
) => {
  if (!style) {
    return style;
  }

  if (typeof style === 'object') {
    Object.keys(style).forEach(k => {
      if (k === 'animation' || k === 'animationName') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const styleVal = style as any;
        styleVal[k] = findReferencedKeyframe(styleVal[k], keyframes);
      }
    });
  }
};

const findReferencedKeyframe = (val: string, keyframes: { [key: string]: string }) => {
  if (typeof val === 'string') {
    return val.replace(refRegExp, (match, name) => {
      if (name in keyframes) {
        return keyframes[name];
      }

      warn(`makeAnimations: referenced keyframes rule "$${name}" is not defined.`);

      return match;
    });
  }

  return val;
};
