import { IKeyframes, IStyle } from '@fluentui/merge-styles';
import { Theme } from '@fluentui/theme';
import { useTheme } from './useTheme';
import { useWindow } from '@fluentui/react-window-provider';
import { useStyleRenderer } from './styleRenderers/useStyleRenderer';
import { StyleRenderer, StyleRendererOptions } from './styleRenderers/types';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const graphGet = (graphNode: Map<any, any>, path: any[]): any | undefined => {
  for (const key of path) {
    graphNode = graphNode.get(key);

    if (!graphNode) {
      return;
    }
  }

  return graphNode;
};

type Style = Omit<IStyle, 'animationName'> & {
  animationName?: IStyle;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const graphSet = (graphNode: Map<any, any>, path: any[], value: any) => {
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];

    let current = graphNode.get(key);

    if (!current) {
      current = new Map();

      graphNode.set(key, current);
    }

    graphNode = current;
  }

  graphNode.set(path[path.length - 1], value);
};

/** Options that can be provided to the hook generated by `makeStyles`. */
export type UseStylesOptions = {
  theme?: Theme;
  renderer?: StyleRenderer;
};

/**
 * Registers a css object, optionally as a function of the theme.
 *
 * @param styleOrFunction - Either a css javascript object, or a function which takes in `ITheme`
 * and returns a css javascript object.
 */
export function makeAnimations<TStyleSet extends { [key: string]: Style }>(
  styleOrFunction: TStyleSet | ((theme: Theme) => TStyleSet),
): (options?: UseStylesOptions) => { [key in keyof TStyleSet]: string } {
  // Create graph of inputs to map to output.
  const graph = new Map();

  return (options: UseStylesOptions = {}) => {
    let { theme, renderer } = options;
    const win = useWindow();
    const contextualTheme = useTheme();
    const contextualRenderer = useStyleRenderer();

    theme = theme || contextualTheme || {};
    renderer = (renderer || contextualRenderer) as StyleRenderer;

    const id = renderer.getId();
    const isStyleFunction = typeof styleOrFunction === 'function';
    const path = isStyleFunction ? [id, win, theme] : [id, win];
    let value = graphGet(graph, path);

    if (!value) {
      const userStyles: TStyleSet = isStyleFunction
        ? (styleOrFunction as (theme: Theme) => TStyleSet)(theme!)
        : (styleOrFunction as TStyleSet);
      const styles = { ...userStyles };
      const rendererOptions = { targetWindow: win, rtl: !!theme!.rtl };

      renderKeyframes(renderer, rendererOptions, styles);
      value = renderer.renderStyles(styles, rendererOptions);

      graphSet(graph, path, value);
    }

    return value;
  };
}

function renderKeyframes<TStyleSet extends { [key: string]: Style }>(
  renderer: StyleRenderer,
  rendererOptions: StyleRendererOptions,
  styles: TStyleSet,
): void {
  for (const key in styles) {
    if (styles.hasOwnProperty(key)) {
      const style = styles[key];
      if (Array.isArray(style)) {
        style.forEach(s => {
          renderKeyframesImpl(renderer, rendererOptions, s);
        });
      } else {
        renderKeyframesImpl(renderer, rendererOptions, style);
      }
    }
  }
}

function renderKeyframesImpl(renderer: StyleRenderer, rendererOptions: StyleRendererOptions, styles: Style) {
  for (const sKey in styles) {
    if (sKey === 'animationName') {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const animationName = styles[sKey];
      let keyframes: string | undefined;
      if (Array.isArray(animationName)) {
        const names = animationName.map(ani => {
          return renderer.renderKeyframes(ani as IKeyframes, rendererOptions);
        });
        keyframes = names.join(',');
      } else {
        keyframes = renderer.renderKeyframes(animationName as any, rendererOptions);
      }
      (styles as any)['animationName'] = keyframes;
    }
  }
}
